 strpos($what, $str) - Функция возвращает позицию подстроки $what
в строке $str или false, если подстрока не найдена. Если указан необязательный параметр
$from, то поиск начинается с байта, указанного в этом параметре. 

string trim(string $st [, string $charlist])
Возвращает копию $st, только с удаленными ведущими и концевыми пробельными
символами. Под пробельными символами здесь и далее мы подразумеваем:
 пробел " ";
 символ перевода строки \n;
 символ возврата каретки \r; 
 символ табуляции \t;
 нулевой байт \0;
 вертикальная табуляция \x0B. 


string ltrim(string $st [, string $charlist])
То же, что и trim(), только удаляет исключительно ведущие пробелы, а концевые не
трогает. Используется гораздо реже. Старайтесь всегда вместо нее применять trim(), и
не прогадаете.

string chop(string $st [, string $charlist])
Удаляет только концевые пробелы, ведущие не трогает. Эта функция будет наверняка
очень популярной у тех, кто раньше программировал на Perl. Однако следует заметить,
что в PHP она выполняет другую функцию. 

int strlen(string $st)
Одна из наиболее полезных функций. Возвращает просто длину строки, т. е. количество
содержащихся в $st символов. Работа с данной функцией уже рассматривалась
выше.

int strpos(string $where, string $what [, int $from = 0])
Пытается найти в строке $where подстроку (т. е. последовательность символов) $what и
в случае успеха возвращает позицию (индекс) этой подстроки в строке. Первый символ
строки, как и в C, имеет индекс 0. Необязательный параметр $from можно задавать, если
поиск нужно вести не с начала строки $where, а с какой-то другой позиции. В этом случае
следует позицию передать в $from. Если подстроку найти не удалось, функция возвращает
false. Однако будьте внимательны, проверяя результат вызова strpos() на
false — используйте для этого только оператор === (выше было описано, почему).

int strrpos(string $where, char $what [, int $from = 0])
Данная функция похожа strpos(), но несет несколько иную нагрузку. Она ищет в строке
$where последнюю позицию, в которой встречается подстрока $what. В случае, если
совпадение не найдено, возвращается false. 

int strcmp(string $str1, string $str2)
Сравнивает две строки посимвольно (точнее, побайтово) и возвращает: 0, если строки
полностью совпадают; ?1, если строка $str1 лексикографически меньше $str2; 1, если,
наоборот, $str1 "больше" $str2. Так как сравнение идет побайтово, то регистр символов
влияет на результаты сравнений.
В двух строках разной длины каждый символ более длинной строки без соответствующего
символа в более короткой строке принимает значение "больше". Например, "Xs"
больше, чем "X". Пустые строки могут быть равны только другим пустым строкам, и
они являются наименьшими текстовыми значениями.
Начиная с PHP 7, вместо данной функции можно использовать оператор <=>.

int strcasecmp(string $str1, string $str2)
То же самое, что и strcmp(), только при работе не учитывается регистр букв. Например,
с точки зрения этой функции "ab" и "AB" равны. 

string substr(string $str, int $start [,int $length])
Данная функция тоже применяется очень часто. Ее назначение — возвращать участок
строки $str, начиная с позиции $start и длиной $length. Если $length не задана, то
подразумевается подстрока от $start до конца строки $str. Если $start больше, чем
длина строки, или же значение $length равно нулю, то возвращается пустая подстрока.
Однако эта функция может делать и еще довольно полезные вещи. К примеру, если мы
передадим в $start отрицательное число, то будет считаться, что это число является
индексом подстроки, но только отсчитываемым от конца $str (например, ?1 означает
"начиная с последнего символа строки"). Параметр $length, если он задан, тоже может
быть отрицательным. В этом случае последним символом возвращенной подстроки
будет символ из $str с индексом $length, определяемым от конца строки. 

string str_replace(string $from, string $to, mixed $text [, int &$count])
Заменяет в строке $text все вхождения подстроки $from (с учетом регистра) на $to и
возвращает результат. Исходная строка, переданная третьим параметром, при этом не 
Глава 13. Строковые функции 263
меняется. Если указан необязательный параметр $count, в него будет записано количество
произведенных замен. Эта функция работает значительно быстрее, чем более универсальная
preg_replace()

string str_ireplace(string $from, string $to, string $text [, int &$count])
Она работает так же, как str_replace(), но только заменяет строки без учета регистра
символов.

string substr_replace(string $text, string $to, int $start [,int $len])
Функция предназначена для замены в строке $text участка, начинающегося с позиции
$start и длины $len. Этот участок заменяется значением параметра $to. 

string str_replace(list $from, list $to, mixed $text [, int &$count])
Выше мы уже рассматривали функцию str_replace() и говорили, что первые два параметра
должны иметь строковый тип. Чаще всего так и происходит. Однако функция
str_replace() значительно мощнее и позволяет передавать в качестве аргументов целые
массивы строк.
Если $from и $to — массивы, замена происходит так: каждый элемент из $from заменяется
соответствующим (по номеру) элементом из $to

string strtr(string $str, string $from, string $to)
Эта функция применяется не столь широко, но все-таки иногда бывает довольно полезной.
Делает она следующее: в строке $str заменяет все символы, встречающиеся
в $from, их "парными" (т. е. расположенными в тех же позициях, что и во $from) из $to.

string strtr(string $str, array $substitutes)
Как видите, у функции strtr() существует две разновидности: первая — с тремя параметрами
(рассмотрена выше), а вторая — с двумя. Рассмотрим подробно второй вариант.

Функция strtr() с двумя параметрами берет строку $str и проводит в ней контекстный
поиск и замену: ищутся подстроки — ключи в массиве $substitutes — и замещаются
на соответствующие им значения. Это похоже на то, что делает функция
str_replace(), когда ей передаются списки в качестве первых аргументов. Однако есть
и определенные отличия, которые мы вскоре рассмотрим. 

string urlencode(string $st)
Функция URL-кодирует строку $st и возвращает результат. Эту функцию удобно применять,
если вы, например, хотите динамически сформировать ссылку <a href=...> на
какой-то сценарий, но не уверены, что его параметры содержат только алфавитноцифровые
символы. В этом случае воспользуйтесь функцией так:
echo "<a href='/script.php?param=".urlencode($userData)."'>ссылка</a>";
Теперь, даже если переменная $userData включает символы =, & или пробелы, все равно
сценарию будут переданы корректные данные.
string urldecode(string $st)
Производит URL-декодирование строки. В принципе, используется значительно реже,
чем urlencode(), потому что PHP и так умеет перекодировать входные данные автоматически.

string rawurlencode(string $st)
Почти полностью аналогична urlencode(), но только пробелы не преобразуются в +, как
это делается при передаче данных из формы, а воспринимаются как обычные неалфавитно-цифровые
символы. Впрочем, этот метод не порождает никаких дополнительных
несовместимостей в коде.

string rawurldecode(string $st)
Аналогична urldecode(), но не воспринимает + как пробел. 

string strtolower(string $st)
Преобразует строку $st в нижний регистр. Возвращает результат перевода.

string strtoupper(string $st)
Переводит строку $st в верхний регистр. Возвращает результат преобразования. Эта
функция также прекрасно работает со строками, составленными из латинских букв, но
с кириллицей может возникнуть все та же проблема.

string ucfirst(string $st)
Преобразует в верхний регистр только первую букву в строке $st, не трогая остальные. 

string setlocale(int $category, string $locale)
Функция устанавливает текущую локаль $locale, с которой будут работать функции
преобразования регистра символов, вывода даты/времени и т. д. Вообще говоря, для
каждой категории функций локаль определяется отдельно и выглядит по-разному. То,
какую именно категорию функций затронет вызов setlocale(), задается в параметре
$category. Он может принимать следующие целые значения, для которых в PHP предусмотрены
специальные константы:
 LC_CTYPE — активизирует указанную локаль для функций перевода в верхний/
нижний регистры;
 LC_NUMERIC — активизирует локаль для функций форматирования дробных чисел, а
именно задает разделитель целой и дробной части в числах;
 LC_TIME — задает формат вывода даты и времени по умолчанию;
 LC_ALL — устанавливает все вышеперечисленные режимы.

string sprintf(string $format [, mixed args, ...])
Эта функция — аналог функции sprintf() в языке C. Она возвращает строку, составленную
на основе строки форматирования, содержащей некоторые специальные символы,
которые будут впоследствии заменены значениями соответствующих переменных
из списка аргументов. 
Необязательный заполнитель — символ заполнения, который будет использован,
если выводимая величина занимает меньше знакомест, чем имеет отведенное для
нее поле. В качестве символов-заполнителей может использоваться пробел или 0, по
умолчанию подставляется пробел. Можно задать любой другой знак, если указать
его в строке форматирования, предварив апострофом (').
 Необязательный спецификатор выравнивания, определяющий, будет результат выровнен
по правому или по левому краю поля. По умолчанию производится выравнивание
по правому краю, однако можно указать и левое выравнивание, задав символ
- (дефис).
 Необязательное число, определяющее размер поля для вывода величины. Если результат
не будет в поле помещаться, то он "вылезет" за края этого поля, но без усечения.

 Необязательное число, предваренное точкой ("."), предписывающее точность, —
количество знаков после запятой в результирующей строке. Этот спецификатор
учитывается лишь в том случае, если происходит вывод числа с плавающей точкой,
в противном случае он игнорируется.
 Наконец, обязательный (заметьте — единственный обязательный!) спецификатор
типа величины, которая будет помещена в выходную строку:
• b — очередной аргумент из списка выводится как двоичное целое число;
• c — выводится символ с указанным в аргументе кодом;
• d — целое число;
• f — число с плавающей точкой;
• o — восьмеричное целое число;
• s — строка символов;
• x — шестнадцатеричное целое число с маленькими буквами a–f;
• X — шестнадцатеричное число с большими буквами A–F. 

void printf(string $format [, mixed args, ...])
Делает то же самое, что и функция sprintf(), только результирующая строка не возвращается,
а направляется в браузер пользователя. 

string nl2br(string $st [, bool $is_xhtml = true])
Заменяет в строке $st все символы новой строки \n на <br />\n и возвращает результат.
Исходная строка не изменяется. Если необязательный параметр $is_xhtml принимает
значение false, то вместо тега в XHTML-формате <br /> подставляется тег <br>. 

string pack(string $format [, mixed $args, ...])
Функция pack() упаковывает заданные аргументы в бинарную строку, которая затем и
возвращается. Формат параметров, а также их количество, задается при помощи строки
$format, которая представляет собой набор однобуквенных спецификаторов формати-
рования — наподобие тех, что указываются в sprintf(), но только без знака %
 Ниже приведен полный список спецификаторов
формата:
 a — строка, свободные места в поле заполняются символом с кодом 0;
 A — строка, свободные места заполняются пробелами;
 h — шестнадцатеричная строка, младшие разряды в начале;
 H — шестнадцатеричная строка, старшие разряды в начале;
 c — знаковый байт (символ);
 C — беззнаковый байт;
 s — знаковое короткое целое (16 битов, порядок байтов определяется архитектурой
процессора);
 S — беззнаковое короткое целое;
 n — беззнаковое целое (16 битов, старшие разряды в конце);
 v — беззнаковое целое (16 битов, младшие разряды в конце);
 i — знаковое целое (размер и порядок байтов определяется архитектурой);
 I — беззнаковое целое;
 l — знаковое длинное целое (32 бита, порядок байтов определяется архитектурой);
 L — беззнаковое длинное целое;
 N — беззнаковое длинное целое (32 бита, старшие разряды в конце);
 V — беззнаковое целое (32 бита, младшие разряды в конце);
 f — число с плавающей точкой (зависит от архитектуры);
 d — число с плавающей точкой двойной точности (зависит от архитектуры);
 x — символ с нулевым кодом;
 X — возврат назад на 1 байт;
 @ — заполнение нулевым кодом до заданной абсолютной позиции. 

string md5(string $st [, bool $raw_output = false ])
Возвращает хэш-код MD5 строки $st, основанный на алгоритме корпорации RSA Data
Security под названием "MD5 Message-Digest Algorithm". Хэш-код — это просто строка,
почти уникальная для каждой из строк $st. То есть вероятность, что две разные строки,
переданные в $st, дадут нам одинаковый хэш-код, стремится к нулю. 

int crc32(string $st)
Функция crc32() вычисляет 32-битную контрольную сумму строки $st. То есть, результат
ее работы — 32-битное (4-байтовое) целое число. Эта функция работает быстрее
md5(), но в то же время выдает гораздо менее надежные хэш-коды для строки. 

string crypt(string $st [,string $salt])
Алгоритм шифрования DES до недавнего времени был стандартным для всех версий
UNIX и использовался как раз для кодирования паролей пользователей (тем же самым
способом, о котором мы говорили при рассмотрении функции md5()). Но в последнее
время MD5 постепенно начал его вытеснять. Это и понятно: алгоритм MD5 гораздо
надежнее. Рекомендуем и вам везде применять md5() вместо crypt(). 

string random_bytes(int $length)
Функция принимает в качестве единственного аргумента количество байтов, которое
должно получиться в генерируемой строке, и возвращает строку. Особенностью функции
является очень хорошее распределение случайных чисел

void flush()
Эта функция имеет очень и очень отдаленное отношение к работе со строками, но она
еще дальше отстоит от других функций. Именно поэтому мы включили ее в данную
главу. Начнем издалека: обычно при использовании echo данные не прямо сразу отправляются
клиенту, а накапливаются в специальном буфере, чтобы потом транспортироваться
большой "пачкой". Так получается быстрее. Однако иногда бывает нужно
досрочно отправить все данные из буфера пользователю, например, если вы что-то выводите
в реальном времени (так зачастую работают чаты). Вот тут-то вам и поможет
функция flush(), которая отправляет содержимое буфера echo в браузер пользователя