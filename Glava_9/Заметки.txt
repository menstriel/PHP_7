Конструкция if-else имеет еще один альтернативный синтаксис:
if (логическое_выражение):
 команды;
elseif (другое_логическое_выражение):
 другие_команды;
else:
 иначе_команды;
endif 

Цикл с предусловием while
Эта конструкция также унаследована непосредственно от C. Ее предназначение — цикличное
выполнение команд в теле цикла, включающее предварительную проверку,
нужно ли это делать (истинно ли логическое выражение в заголовке). Если не нужно
(выражение ложно), то конструкция заканчивает свою работу, иначе выполняет очередную
итерацию и начинает все сначала. Выглядит цикл так:
while (логическое_выражение)
 инструкция;
где, как обычно, логическое_выражение — логическое выражение, а инструкция — простая
или составная инструкция тела цикла.;

Аналогично инструкции if, цикл while имеет альтернативный синтаксис, что упрощает
его применение совместно с HTML-кодом:
while (логическое_выражение):
 команды;
endwhile; 

do-while
В отличие от цикла while, этот цикл проверяет значение выражения не до, а после каждого
прохода. 
do {
 команды;
} while (логическое_выражение); 

for
for (инициализирующие_команды; условие_цикла; команды_после_прохода)
 тело_цикла;
 Работает он следующим образом. Как только управление доходит до цикла, первым
делом выполняются операторы, включенные в инициализирующие_команды (слева направо).
Эти команды перечисляются через запятую, например:
for ($i = 0, $j = 10, $k = "Test!"; ...)
Затем начинается итерация. Сначала проверяется, выполняется ли условие_цикла (как
в конструкции while). Если да, то все в порядке, и цикл продолжается. Иначе осуществляется
выход из конструкции. 
Альтернативный синтаксис конструкции:
for (инициализирующие_команды; условие_цикла; команды_после_прохода):
 операторы;
endfor; 

break -- осуществляет немедленный выход из цикла. Она может задаваться с одним необязательным параметром —
числом, которое указывает, из какого вложенного цикла должен быть произведен
выход;

continue
Инструкция continue так же, как и break, работает только "в паре" с циклическими конструкциями.
Она немедленно завершает текущую итерацию цикла и переходит к новой
(конечно, если выполняется условие цикла для цикла с предусловием). Точно так же,
как и для break, для continue можно указать уровень вложенности цикла, который будет
продолжен по возврату управления.  

if (что_то) do { ... } while (0); 

foreach
foreach (массив as $ключ => $значение)
 команды; 

 У цикла foreach имеется и другая форма записи, которую следует применять, когда нас
не интересует значение ключа очередного элемента. Выглядит она так:
foreach ($массив as $значение)
 команды; 

 Для того чтобы иметь возможность изменять массив изнутри тела цикла, в PHP можно
использовать ссылочный синтаксис:
foreaсh ($массив as $ключ=>&$значение) {
 // здесь можно изменять $значение, при этом изменяются элементы
 // исходного массива $массив
}

switch-case:
switch (выражение) {
 case значение1: команды1; [break;]
 case значение2: команды2; [break;]
 . . .
 case значениеN: командыN; [break;]
 [default: команды_по_умолчанию; [break]]
} 

Вот альтернативный синтаксис для конструкции switch-case:
switch (выражение):
 case значение1: команды1; [break;]
 . . .
 case значениеN: командыN; [break;]
 [default: команды_по_умолчанию; [break]]
endswitch; 


Начиная с версии 5.3, в PHP введен оператор goto. Оператор позволяет осуществлять
безусловный переход на метку, название которой указывается в качестве единственного
аргумента.
goto метка;
...
метка:


require
формат такой:
require имя_файла;
При запуске программы интерпретатор просто заменит инструкцию на содержимое
файла имя_файла (этот файл может также содержать сценарий на PHP, обрамленный, как
обычно, тегами <?php и ?>). 
Инструкция include практически идентична require, за исключением того, что в случае
невозможности включения файла работа сценария не завершается немедленно, а продолжается
(с выводом соответствующего диагностического сообщения). В большинстве
случаев вряд ли ее использование окажется целесообразным. 

require_once
Инструкция require_once работает точно так же, как и require, но за одним важным исключением.
Если она видит, что затребованный файл уже был ранее включен, то ничего
не делает. 
Инструкция include_once работает совершенно аналогично, но в случае невозможности
найти включаемый файл работа скрипта продолжается, а не завершается немедленно. 
Везде, где только возможно, применяйте инструкции с суффиксом once. Постарайтесь
вообще отказаться от require и include. Это упростит разбиение большой и сложной
программы на относительно независимые модули. 

Другие инструкции
В PHP существует еще масса других инструкций:
 function — объявление функции;
 return — возврат из функции;
 yield — передача управления из генератора;
 class — объявление класса;
 new — создание объекта;
 var, private, static, public — определение свойства класса;
 throw — генерация исключения;
 try-catch — перехват исключения